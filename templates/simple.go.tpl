// This code is generated by https://github.com/jtyers/slice
// DO NOT EDIT!

// nfn: {{ .NewFuncName }}

package {{ .Package }}
{{ if .Imports }}

import (
  {{ .Imports }}
)
{{ end }}
type chain{{ .TypeNameCapitalised }} struct {
	value []{{ .TypeName }}
}

func {{ .NewFuncName }}(slice []{{ .TypeName }}) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: slice}
}

func (c *chain{{ .TypeNameCapitalised }}) Value() []{{ .TypeName }} {
	return c.value
}

func Concat{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}, slice2 []{{ .TypeName }}) (res []{{ .TypeName }}) {
	res = make([]{{ .TypeName }}, 0, len(slice) + len(slice2))
	for _, entry := range slice {
		res = append(res, entry)
	}
	for _, entry := range slice2 {
		res = append(res, entry)
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Concat(slice2 []{{ .TypeName }}) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: Concat{{ .TypeNameCapitalised }}(c.value, slice2)}
}

func Drop{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}, n int) (res []{{ .TypeName }}) {
	l := len(slice) - n
	if l < 0 {
		l = 0
	}
	res = make([]{{ .TypeName }}, 0, l)
	for _, entry := range slice[len(slice) - l:] {
		res = append(res, entry)
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Drop(n int) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: Drop{{ .TypeNameCapitalised }}(c.value, n)}
}

func DropRight{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}, n int) (res []{{ .TypeName }}) {
	l := len(slice) - n
	if l < 0 {
		l = 0
	}
	res = make([]{{ .TypeName }}, 0, l)
	for _, entry := range slice[:l] {
		res = append(res, entry)
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) DropRight(n int) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: DropRight{{ .TypeNameCapitalised }}(c.value, n)}
}

func Filter{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}, fn func({{ .TypeName }},int)bool) (res []{{ .TypeName }}) {
	res = make([]{{ .TypeName }}, 0, len(slice))
	for index, entry := range slice {
		if fn(entry, index) {
			res = append(res, entry)
		}
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Filter(fn func({{ .TypeName }},int)bool) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: Filter{{ .TypeNameCapitalised }}(c.value, fn)}
}

func First{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}) (res {{ .TypeName }}) {
	if len(slice) == 0 {
		return
	}
	res = slice[0]
	return
}

func (c *chain{{ .TypeNameCapitalised }}) First() *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: []{{ .TypeName }}{First{{ .TypeNameCapitalised }}(c.value)}}
}

func Last{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}) (res {{ .TypeName }}) {
	if len(slice) == 0 {
		return
	}
	res = slice[len(slice) - 1]
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Last() *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: []{{ .TypeName }}{Last{{ .TypeNameCapitalised }}(c.value)}}
}

func Map{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}, fn func({{ .TypeName }},int){{ .TypeName }}) (res []{{ .TypeName }}) {
	res = make([]{{ .TypeName }}, 0, len(slice))
	for index, entry := range slice {
		res = append(res, fn(entry, index))
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Map(fn func({{ .TypeName }},int){{ .TypeName }}) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: Map{{ .TypeNameCapitalised }}(c.value, fn)}
}


func Reduce{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}, fn func({{ .TypeName }},{{ .TypeName }},int){{ .TypeName }}, initial {{ .TypeName }}) (res {{ .TypeName }}) {
	res = initial
	for index, entry := range slice {
		res = fn(res, entry, index)
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Reduce(fn func({{ .TypeName }},{{ .TypeName }},int){{ .TypeName }}, initial {{ .TypeName }}) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: []{{ .TypeName }}{Reduce{{ .TypeNameCapitalised }}(c.value, fn, initial)}}
}

func Reverse{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}) (res []{{ .TypeName }}) {
	res = make([]{{ .TypeName }}, len(slice))
	for index, entry := range slice {
		res[len(slice)-1-index] = entry
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Reverse() *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: Reverse{{ .TypeNameCapitalised }}(c.value)}
}

func Uniq{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}) (res []{{ .TypeName }}) {
	seen := make(map[{{ .TypeName }}]bool)
	res = []{{ .TypeName }}{}
	for _, entry := range slice {
		if _, found := seen[entry]; !found {
			seen[entry] = true
			res = append(res, entry)
		}
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Uniq() *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: Uniq{{ .TypeNameCapitalised }}(c.value)}
}
