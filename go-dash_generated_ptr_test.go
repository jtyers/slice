// This code is generated by https://github.com/jtyers/slice
// DO NOT EDIT!

// nfn: NewStringPtrSlice

package main

type chainStringPtr struct {
  isPtr bool
	value []*string
}

func NewStringPtrSlice(slice []*string) *chainStringPtr {
	return &chainStringPtr{
		value: slice,
		isPtr: true,
	}
}

func (c *chainStringPtr) Value() []*string {
	return c.value
}

func ConcatStringPtr(slice []*string, slice2 []*string) (res []*string) {
	res = make([]*string, 0, len(slice) + len(slice2))
	for _, entry := range slice {
		res = append(res, entry)
	}
	for _, entry := range slice2 {
		res = append(res, entry)
	}
	return
}

func (c *chainStringPtr) Concat(slice2 []*string) *chainStringPtr {
	return &chainStringPtr{value: ConcatStringPtr(c.value, slice2)}
}

func DropStringPtr(slice []*string, n int) (res []*string) {
	l := len(slice) - n
	if l < 0 {
		l = 0
	}
	res = make([]*string, 0, l)
	for _, entry := range slice[len(slice) - l:] {
		res = append(res, entry)
	}
	return
}

func (c *chainStringPtr) Drop(n int) *chainStringPtr {
	return &chainStringPtr{value: DropStringPtr(c.value, n)}
}

func DropRightStringPtr(slice []*string, n int) (res []*string) {
	l := len(slice) - n
	if l < 0 {
		l = 0
	}
	res = make([]*string, 0, l)
	for _, entry := range slice[:l] {
		res = append(res, entry)
	}
	return
}

func (c *chainStringPtr) DropRight(n int) *chainStringPtr {
	return &chainStringPtr{value: DropRightStringPtr(c.value, n)}
}

func FilterStringPtr(slice []*string, fn func(*string,int)bool) (res []*string) {
	res = make([]*string, 0, len(slice))
	for index, entry := range slice {
		if fn(entry, index) {
			res = append(res, entry)
		}
	}
	return
}

func (c *chainStringPtr) Filter(fn func(*string,int)bool) *chainStringPtr {
	return &chainStringPtr{value: FilterStringPtr(c.value, fn)}
}

func FirstStringPtr(slice []*string) (res *string) {
	if len(slice) == 0 {
		return
	}
	res = slice[0]
	return
}

func (c *chainStringPtr) First() *chainStringPtr {
	return &chainStringPtr{value: []*string{FirstStringPtr(c.value)}}
}

func LastStringPtr(slice []*string) (res *string) {
	if len(slice) == 0 {
		return
	}
	res = slice[len(slice) - 1]
	return
}

func (c *chainStringPtr) Last() *chainStringPtr {
	return &chainStringPtr{value: []*string{LastStringPtr(c.value)}}
}

func MapStringPtr(slice []*string, fn func(*string,int)*string) (res []*string) {
	res = make([]*string, 0, len(slice))
	for index, entry := range slice {
		res = append(res, fn(entry, index))
	}
	return
}

func (c *chainStringPtr) Map(fn func(*string,int)*string) *chainStringPtr {
	return &chainStringPtr{value: MapStringPtr(c.value, fn)}
}


func ReduceStringPtr(slice []*string, fn func(*string,*string,int)*string, initial *string) (res *string) {
	res = initial
	for index, entry := range slice {
		res = fn(res, entry, index)
	}
	return
}

func (c *chainStringPtr) Reduce(fn func(*string,*string,int)*string, initial *string) *chainStringPtr {
	return &chainStringPtr{value: []*string{ReduceStringPtr(c.value, fn, initial)}}
}

func ReverseStringPtr(slice []*string) (res []*string) {
	res = make([]*string, len(slice))
	for index, entry := range slice {
		res[len(slice)-1-index] = entry
	}
	return
}

func (c *chainStringPtr) Reverse() *chainStringPtr {
	return &chainStringPtr{value: ReverseStringPtr(c.value)}
}

func UniqStringPtr(slice []*string) (res []*string) {
	seen := make(map[*string]bool)
	res = []*string{}
	for _, entry := range slice {
		if _, found := seen[entry]; !found {
			seen[entry] = true
			res = append(res, entry)
		}
	}
	return
}

func (c *chainStringPtr) Uniq() *chainStringPtr {
	if c.isPtr {
		panic("Uniq() does not currently support pointers")
	}
	return &chainStringPtr{value: UniqStringPtr(c.value)}
}
