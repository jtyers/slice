package main

import (
	"flag"
	"fmt"
	"os"
	"path"
	"strings"
	"text/template"
)

const TEMPLATE = `// This code is generated by https://github.com/jtyers/slice
// DO NOT EDIT!

// nfn: {{ .NewFuncName }}

package {{ .Package }}
{{ if .Imports }}

import (
  {{ .Imports }}
)
{{ end }}
type chain{{ .TypeNameCapitalised }} struct {
	value []{{ .TypeName }}
}

func {{ .NewFuncName }}(slice []{{ .TypeName }}) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: slice}
}

func (c *chain{{ .TypeNameCapitalised }}) Value() []{{ .TypeName }} {
	return c.value
}

func Concat{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}, slice2 []{{ .TypeName }}) (res []{{ .TypeName }}) {
	res = make([]{{ .TypeName }}, 0, len(slice) + len(slice2))
	for _, entry := range slice {
		res = append(res, entry)
	}
	for _, entry := range slice2 {
		res = append(res, entry)
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Concat(slice2 []{{ .TypeName }}) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: Concat{{ .TypeNameCapitalised }}(c.value, slice2)}
}

func Drop{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}, n int) (res []{{ .TypeName }}) {
	l := len(slice) - n
	if l < 0 {
		l = 0
	}
	res = make([]{{ .TypeName }}, 0, l)
	for _, entry := range slice[len(slice) - l:] {
		res = append(res, entry)
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Drop(n int) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: Drop{{ .TypeNameCapitalised }}(c.value, n)}
}

func DropRight{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}, n int) (res []{{ .TypeName }}) {
	l := len(slice) - n
	if l < 0 {
		l = 0
	}
	res = make([]{{ .TypeName }}, 0, l)
	for _, entry := range slice[:l] {
		res = append(res, entry)
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) DropRight(n int) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: DropRight{{ .TypeNameCapitalised }}(c.value, n)}
}

func Filter{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}, fn func({{ .TypeName }},int)bool) (res []{{ .TypeName }}) {
	res = make([]{{ .TypeName }}, 0, len(slice))
	for index, entry := range slice {
		if fn(entry, index) {
			res = append(res, entry)
		}
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Filter(fn func({{ .TypeName }},int)bool) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: Filter{{ .TypeNameCapitalised }}(c.value, fn)}
}

func First{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}) (res {{ .TypeName }}) {
	if len(slice) == 0 {
		return
	}
	res = slice[0]
	return
}

func (c *chain{{ .TypeNameCapitalised }}) First() *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: []{{ .TypeName }}{First{{ .TypeNameCapitalised }}(c.value)}}
}

func Last{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}) (res {{ .TypeName }}) {
	if len(slice) == 0 {
		return
	}
	res = slice[len(slice) - 1]
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Last() *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: []{{ .TypeName }}{Last{{ .TypeNameCapitalised }}(c.value)}}
}

func Map{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}, fn func({{ .TypeName }},int){{ .TypeName }}) (res []{{ .TypeName }}) {
	res = make([]{{ .TypeName }}, 0, len(slice))
	for index, entry := range slice {
		res = append(res, fn(entry, index))
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Map(fn func({{ .TypeName }},int){{ .TypeName }}) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: Map{{ .TypeNameCapitalised }}(c.value, fn)}
}


func Reduce{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}, fn func({{ .TypeName }},{{ .TypeName }},int){{ .TypeName }}, initial {{ .TypeName }}) (res {{ .TypeName }}) {
	res = initial
	for index, entry := range slice {
		res = fn(res, entry, index)
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Reduce(fn func({{ .TypeName }},{{ .TypeName }},int){{ .TypeName }}, initial {{ .TypeName }}) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: []{{ .TypeName }}{Reduce{{ .TypeNameCapitalised }}(c.value, fn, initial)}}
}

func Reverse{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}) (res []{{ .TypeName }}) {
	res = make([]{{ .TypeName }}, len(slice))
	for index, entry := range slice {
		res[len(slice)-1-index] = entry
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Reverse() *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: Reverse{{ .TypeNameCapitalised }}(c.value)}
}

func Uniq{{ .TypeNameCapitalised }}(slice []{{ .TypeName }}) (res []{{ .TypeName }}) {
	seen := make(map[{{ .TypeName }}]bool)
	res = []{{ .TypeName }}{}
	for _, entry := range slice {
		if _, found := seen[entry]; !found {
			seen[entry] = true
			res = append(res, entry)
		}
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Uniq() *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: Uniq{{ .TypeNameCapitalised }}(c.value)}
}
`

func main() {
	var flagPkg string
	var flagImport string
	var flagTypeName string
	var flagOutputDir string
	var flagOutputFile string

	flag.StringVar(&flagPkg, "package", "godash", "set the package name on generated files")
	flag.StringVar(&flagImport, "import", "", "add an import to generated files (needed for custom types)")
	flag.StringVar(&flagTypeName, "type", "string", "the type of slice to generate for")
	flag.StringVar(&flagOutputDir, "dir", "go-dash-slice", "output directory (created if needed)")
	flag.StringVar(&flagOutputFile, "out", "", "output filename")

	if flagOutputFile == "" {
		flagOutputFile = flagTypeName + ".go"
	}

	flag.Parse()

	t := template.New("go-dash-slice")
	t, err := t.Parse(TEMPLATE)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to load template: %s", err.Error())
		os.Exit(1)
	}

	err = os.MkdirAll(flagOutputDir, 0755)
	if err != nil {
		fmt.Fprintf(os.Stderr, "mkdir: %s", err.Error())
		os.Exit(1)
	}

	f, err := os.OpenFile(path.Join(flagOutputDir, flagOutputFile), os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		fmt.Fprintf(os.Stderr, "open: %s", err.Error())
		os.Exit(1)
	}

	typeNameCapitalised := strings.ToUpper(flagTypeName[0:1]) + flagTypeName[1:]

	err = t.Execute(f, map[string]interface{}{
		"TypeNameCapitalised": typeNameCapitalised,
		"TypeName":            flagTypeName,
		"Package":             flagPkg,
		"Import":              flagImport,
		"NewFuncName":         "New" + typeNameCapitalised + "Slice",
	})
	if err != nil {
		fmt.Fprintf(os.Stderr, "template execute: %s", err.Error())
		os.Exit(1)
	}
}
