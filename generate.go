package main

import (
	"flag"
	"fmt"
	"os"
	"path"
	"strings"
	"text/template"
)

const TEMPLATE = `// This code is generated by https://github.com/jtyers/slice
// DO NOT EDIT!

{{ if .BuildTag }}
// +build {{ .BuildTag }}
{{ end }}

package {{ .Package }}
{{ if .Import }}

import (
  . "{{ .Import }}"
)
{{ end }}
type chain{{ .TypeNameCapitalised }} struct {
  isPtr bool
	value []{{ .TypeLiteral }}
}

func {{ .NewFuncName }}(slice []{{ .TypeLiteral }}) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{
		value: slice,
		{{ if .IsPtr }}isPtr: true,{{ end }}
	}
}

func (c *chain{{ .TypeNameCapitalised }}) Value() []{{ .TypeLiteral }} {
	return c.value
}

func Concat{{ .TypeNameCapitalised }}(slice []{{ .TypeLiteral }}, slice2 []{{ .TypeLiteral }}) (res []{{ .TypeLiteral }}) {
	res = make([]{{ .TypeLiteral }}, 0, len(slice) + len(slice2))
	for _, entry := range slice {
		res = append(res, entry)
	}
	for _, entry := range slice2 {
		res = append(res, entry)
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Concat(slice2 []{{ .TypeLiteral }}) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: Concat{{ .TypeNameCapitalised }}(c.value, slice2)}
}

func Contains{{ .TypeNameCapitalised }}(slice []{{ .TypeLiteral }}, item {{ .TypeLiteral }}) (res bool) {
	for _, val := range slice {
		if val == item {
			return true
		}
		{{ if .IsPtr}}if *val == *item {
			return true
		}{{ end }}
	}
	return false
}

func (c *chain{{ .TypeNameCapitalised }}) Contains(item {{ .TypeLiteral }}) bool {
	return Contains{{ .TypeNameCapitalised }}(c.value, item)
}

func Drop{{ .TypeNameCapitalised }}(slice []{{ .TypeLiteral }}, n int) (res []{{ .TypeLiteral }}) {
	l := len(slice) - n
	if l < 0 {
		l = 0
	}
	res = make([]{{ .TypeLiteral }}, 0, l)
	for _, entry := range slice[len(slice) - l:] {
		res = append(res, entry)
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Drop(n int) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: Drop{{ .TypeNameCapitalised }}(c.value, n)}
}

func DropRight{{ .TypeNameCapitalised }}(slice []{{ .TypeLiteral }}, n int) (res []{{ .TypeLiteral }}) {
	l := len(slice) - n
	if l < 0 {
		l = 0
	}
	res = make([]{{ .TypeLiteral }}, 0, l)
	for _, entry := range slice[:l] {
		res = append(res, entry)
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) DropRight(n int) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: DropRight{{ .TypeNameCapitalised }}(c.value, n)}
}

func Filter{{ .TypeNameCapitalised }}(slice []{{ .TypeLiteral }}, fn func({{ .TypeLiteral }},int)bool) (res []{{ .TypeLiteral }}) {
	res = make([]{{ .TypeLiteral }}, 0, len(slice))
	for index, entry := range slice {
		if fn(entry, index) {
			res = append(res, entry)
		}
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Filter(fn func({{ .TypeLiteral }},int)bool) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: Filter{{ .TypeNameCapitalised }}(c.value, fn)}
}

func First{{ .TypeNameCapitalised }}(slice []{{ .TypeLiteral }}) (res {{ .TypeLiteral }}) {
	if len(slice) == 0 {
		return
	}
	res = slice[0]
	return
}

func (c *chain{{ .TypeNameCapitalised }}) First() *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: []{{ .TypeLiteral }}{First{{ .TypeNameCapitalised }}(c.value)}}
}

func Last{{ .TypeNameCapitalised }}(slice []{{ .TypeLiteral }}) (res {{ .TypeLiteral }}) {
	if len(slice) == 0 {
		return
	}
	res = slice[len(slice) - 1]
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Last() *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: []{{ .TypeLiteral }}{Last{{ .TypeNameCapitalised }}(c.value)}}
}

func Map{{ .TypeNameCapitalised }}(slice []{{ .TypeLiteral }}, fn func({{ .TypeLiteral }},int){{ .TypeLiteral }}) (res []{{ .TypeLiteral }}) {
	res = make([]{{ .TypeLiteral }}, 0, len(slice))
	for index, entry := range slice {
		res = append(res, fn(entry, index))
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Map(fn func({{ .TypeLiteral }},int){{ .TypeLiteral }}) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: Map{{ .TypeNameCapitalised }}(c.value, fn)}
}


func Reduce{{ .TypeNameCapitalised }}(slice []{{ .TypeLiteral }}, fn func({{ .TypeLiteral }},{{ .TypeLiteral }},int){{ .TypeLiteral }}, initial {{ .TypeLiteral }}) (res {{ .TypeLiteral }}) {
	res = initial
	for index, entry := range slice {
		res = fn(res, entry, index)
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Reduce(fn func({{ .TypeLiteral }},{{ .TypeLiteral }},int){{ .TypeLiteral }}, initial {{ .TypeLiteral }}) *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: []{{ .TypeLiteral }}{Reduce{{ .TypeNameCapitalised }}(c.value, fn, initial)}}
}

func Reverse{{ .TypeNameCapitalised }}(slice []{{ .TypeLiteral }}) (res []{{ .TypeLiteral }}) {
	res = make([]{{ .TypeLiteral }}, len(slice))
	for index, entry := range slice {
		res[len(slice)-1-index] = entry
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Reverse() *chain{{ .TypeNameCapitalised }} {
	return &chain{{ .TypeNameCapitalised }}{value: Reverse{{ .TypeNameCapitalised }}(c.value)}
}

func Uniq{{ .TypeNameCapitalised }}(slice []{{ .TypeLiteral }}) (res []{{ .TypeLiteral }}) {
	seen := make(map[{{ .TypeLiteral }}]bool)
	res = []{{ .TypeLiteral }}{}
	for _, entry := range slice {
		if _, found := seen[entry]; !found {
			seen[entry] = true
			res = append(res, entry)
		}
	}
	return
}

func (c *chain{{ .TypeNameCapitalised }}) Uniq() *chain{{ .TypeNameCapitalised }} {
	if c.isPtr {
		panic("Uniq() does not currently support pointers")
	}
	return &chain{{ .TypeNameCapitalised }}{value: Uniq{{ .TypeNameCapitalised }}(c.value)}
}
`

func main() {
	var flagPkg string
	var flagBuildTag string
	var flagImport string
	var flagTypeName string
	var flagOutputDir string
	var flagOutputFile string

	flag.StringVar(&flagPkg, "package", "godash", "set the package name on generated files")
	flag.StringVar(&flagBuildTag, "build-tag", "", "add a build tag to generates files")
	flag.StringVar(&flagImport, "import", "", "add an import to generated files (needed for custom types)")
	flag.StringVar(&flagTypeName, "type", "string", "the type of slice to generate for")
	flag.StringVar(&flagOutputDir, "dir", "go-dash-slice", "output directory (created if needed)")
	flag.StringVar(&flagOutputFile, "out", "", "output filename")

	flag.Parse()

	isPtr := false
	if flagTypeName[0] == '*' {
		isPtr = true
	}

	typeLiteral := flagTypeName
	if isPtr {
		flagTypeName = flagTypeName[1:] + "Ptr"
	}

	if flagOutputFile == "" {
		flagOutputFile = flagTypeName + ".go"
	}

	t := template.New("go-dash-slice")
	t, err := t.Parse(TEMPLATE)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to load template: %s", err.Error())
		os.Exit(1)
	}

	err = os.MkdirAll(flagOutputDir, 0755)
	if err != nil {
		fmt.Fprintf(os.Stderr, "mkdir: %s", err.Error())
		os.Exit(1)
	}

	f, err := os.OpenFile(path.Join(flagOutputDir, flagOutputFile), os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		fmt.Fprintf(os.Stderr, "open: %s", err.Error())
		os.Exit(1)
	}

	typeNameCapitalised := strings.ToUpper(flagTypeName[0:1]) + flagTypeName[1:]

	err = t.Execute(f, map[string]interface{}{
		"BuildTag":            flagBuildTag,
		"IsPtr":               isPtr,
		"TypeNameCapitalised": typeNameCapitalised,
		"TypeLiteral":         typeLiteral,
		"TypeName":            flagTypeName,
		"Package":             flagPkg,
		"Import":              flagImport,
		"NewFuncName":         "New" + typeNameCapitalised + "Slice",
	})
	if err != nil {
		fmt.Fprintf(os.Stderr, "template execute: %s", err.Error())
		os.Exit(1)
	}
}
